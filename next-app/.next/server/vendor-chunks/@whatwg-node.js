"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@whatwg-node";
exports.ids = ["vendor-chunks/@whatwg-node"];
exports.modules = {

/***/ "(ssr)/./node_modules/@whatwg-node/promise-helpers/esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@whatwg-node/promise-helpers/esm/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDeferredPromise: () => (/* binding */ createDeferredPromise),\n/* harmony export */   fakePromise: () => (/* binding */ fakePromise),\n/* harmony export */   fakeRejectPromise: () => (/* binding */ fakeRejectPromise),\n/* harmony export */   handleMaybePromise: () => (/* binding */ handleMaybePromise),\n/* harmony export */   isActualPromise: () => (/* binding */ isActualPromise),\n/* harmony export */   isPromise: () => (/* binding */ isPromise),\n/* harmony export */   iterateAsync: () => (/* binding */ iterateAsync),\n/* harmony export */   iterateAsyncVoid: () => (/* binding */ iterateAsync),\n/* harmony export */   mapAsyncIterator: () => (/* binding */ mapAsyncIterator),\n/* harmony export */   mapMaybePromise: () => (/* binding */ mapMaybePromise),\n/* harmony export */   promiseLikeFinally: () => (/* binding */ promiseLikeFinally),\n/* harmony export */   unfakePromise: () => (/* binding */ unfakePromise)\n/* harmony export */ });\nconst kFakePromise = Symbol.for('@whatwg-node/promise-helpers/FakePromise');\nfunction isPromise(value) {\n    return value?.then != null;\n}\nfunction isActualPromise(value) {\n    const maybePromise = value;\n    return maybePromise && maybePromise.then && maybePromise.catch && maybePromise.finally;\n}\nfunction handleMaybePromise(inputFactory, outputSuccessFactory, outputErrorFactory, finallyFactory) {\n    let result$ = fakePromise().then(inputFactory).then(outputSuccessFactory, outputErrorFactory);\n    if (finallyFactory) {\n        result$ = result$.finally(finallyFactory);\n    }\n    return unfakePromise(result$);\n}\nfunction fakePromise(value) {\n    if (value && isActualPromise(value)) {\n        return value;\n    }\n    if (isPromise(value)) {\n        return {\n            then: (resolve, reject) => fakePromise(value.then(resolve, reject)),\n            catch: reject => fakePromise(value.then(res => res, reject)),\n            finally: cb => fakePromise(cb ? promiseLikeFinally(value, cb) : value),\n            [Symbol.toStringTag]: 'Promise',\n        };\n    }\n    // Write a fake promise to avoid the promise constructor\n    // being called with `new Promise` in the browser.\n    return {\n        then(resolve) {\n            if (resolve) {\n                try {\n                    return fakePromise(resolve(value));\n                }\n                catch (err) {\n                    return fakeRejectPromise(err);\n                }\n            }\n            return this;\n        },\n        catch() {\n            return this;\n        },\n        finally(cb) {\n            if (cb) {\n                try {\n                    return fakePromise(cb()).then(() => value, () => value);\n                }\n                catch (err) {\n                    return fakeRejectPromise(err);\n                }\n            }\n            return this;\n        },\n        [Symbol.toStringTag]: 'Promise',\n        __fakePromiseValue: value,\n        [kFakePromise]: 'resolved',\n    };\n}\nfunction createDeferredPromise() {\n    if (Promise.withResolvers) {\n        return Promise.withResolvers();\n    }\n    let resolveFn;\n    let rejectFn;\n    const promise = new Promise(function deferredPromiseExecutor(resolve, reject) {\n        resolveFn = resolve;\n        rejectFn = reject;\n    });\n    return {\n        promise,\n        get resolve() {\n            return resolveFn;\n        },\n        get reject() {\n            return rejectFn;\n        },\n    };\n}\n\nfunction iterateAsync(iterable, callback, results) {\n    if (iterable?.length === 0) {\n        return;\n    }\n    const iterator = iterable[Symbol.iterator]();\n    let index = 0;\n    function iterate() {\n        const { done: endOfIterator, value } = iterator.next();\n        if (endOfIterator) {\n            return;\n        }\n        let endedEarly = false;\n        function endEarly() {\n            endedEarly = true;\n        }\n        return handleMaybePromise(function handleCallback() {\n            return callback(value, endEarly, index++);\n        }, function handleCallbackResult(result) {\n            if (result) {\n                results?.push(result);\n            }\n            if (endedEarly) {\n                return;\n            }\n            return iterate();\n        });\n    }\n    return iterate();\n}\nfunction fakeRejectPromise(error) {\n    return {\n        then(_resolve, reject) {\n            if (reject) {\n                try {\n                    return fakePromise(reject(error));\n                }\n                catch (err) {\n                    return fakeRejectPromise(err);\n                }\n            }\n            return this;\n        },\n        catch(reject) {\n            if (reject) {\n                try {\n                    return fakePromise(reject(error));\n                }\n                catch (err) {\n                    return fakeRejectPromise(err);\n                }\n            }\n            return this;\n        },\n        finally(cb) {\n            if (cb) {\n                try {\n                    cb();\n                }\n                catch (err) {\n                    return fakeRejectPromise(err);\n                }\n            }\n            return this;\n        },\n        __fakeRejectError: error,\n        [Symbol.toStringTag]: 'Promise',\n        [kFakePromise]: 'rejected',\n    };\n}\nfunction mapMaybePromise(input, onSuccess, onError) {\n    return handleMaybePromise(() => input, onSuccess, onError);\n}\n/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nfunction mapAsyncIterator(iterator, onNext, onError, onEnd) {\n    if (Symbol.asyncIterator in iterator) {\n        iterator = iterator[Symbol.asyncIterator]();\n    }\n    let $return;\n    let abruptClose;\n    let onEndWithValue;\n    if (onEnd) {\n        let onEndWithValueResult /** R in onEndWithValue */;\n        onEndWithValue = value => {\n            onEndWithValueResult ||= handleMaybePromise(onEnd, () => value, () => value);\n            return onEndWithValueResult;\n        };\n    }\n    if (typeof iterator.return === 'function') {\n        $return = iterator.return;\n        abruptClose = (error) => {\n            const rethrow = () => {\n                throw error;\n            };\n            return $return.call(iterator).then(rethrow, rethrow);\n        };\n    }\n    function mapResult(result) {\n        if (result.done) {\n            return onEndWithValue ? onEndWithValue(result) : result;\n        }\n        return handleMaybePromise(() => result.value, value => handleMaybePromise(() => onNext(value), iteratorResult, abruptClose));\n    }\n    let mapReject;\n    if (onError) {\n        let onErrorResult;\n        // Capture rejectCallback to ensure it cannot be null.\n        const reject = onError;\n        mapReject = (error) => {\n            onErrorResult ||= handleMaybePromise(() => error, error => handleMaybePromise(() => reject(error), iteratorResult, abruptClose));\n            return onErrorResult;\n        };\n    }\n    return {\n        next() {\n            return iterator.next().then(mapResult, mapReject);\n        },\n        return() {\n            const res$ = $return\n                ? $return.call(iterator).then(mapResult, mapReject)\n                : fakePromise({ value: undefined, done: true });\n            return onEndWithValue ? res$.then(onEndWithValue) : res$;\n        },\n        throw(error) {\n            if (typeof iterator.throw === 'function') {\n                return iterator.throw(error).then(mapResult, mapReject);\n            }\n            if (abruptClose) {\n                return abruptClose(error);\n            }\n            return fakeRejectPromise(error);\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n}\nfunction iteratorResult(value) {\n    return { value, done: false };\n}\nfunction isFakePromise(value) {\n    return value?.[kFakePromise] === 'resolved';\n}\nfunction isFakeRejectPromise(value) {\n    return value?.[kFakePromise] === 'rejected';\n}\nfunction promiseLikeFinally(value, onFinally) {\n    if ('finally' in value) {\n        return value.finally(onFinally);\n    }\n    return value.then(res => {\n        const finallyRes = onFinally();\n        return isPromise(finallyRes) ? finallyRes.then(() => res) : res;\n    }, err => {\n        const finallyRes = onFinally();\n        if (isPromise(finallyRes)) {\n            return finallyRes.then(() => {\n                throw err;\n            });\n        }\n        else {\n            throw err;\n        }\n    });\n}\nfunction unfakePromise(promise) {\n    if (isFakePromise(promise)) {\n        return promise.__fakePromiseValue;\n    }\n    if (isFakeRejectPromise(promise)) {\n        throw promise.__fakeRejectError;\n    }\n    return promise;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHdoYXR3Zy1ub2RlL3Byb21pc2UtaGVscGVycy9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUM0QztBQUNyQztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDhCQUE4QjtBQUM5RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWFwcC8uL25vZGVfbW9kdWxlcy9Ad2hhdHdnLW5vZGUvcHJvbWlzZS1oZWxwZXJzL2VzbS9pbmRleC5qcz8zMTZmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGtGYWtlUHJvbWlzZSA9IFN5bWJvbC5mb3IoJ0B3aGF0d2ctbm9kZS9wcm9taXNlLWhlbHBlcnMvRmFrZVByb21pc2UnKTtcbmV4cG9ydCBmdW5jdGlvbiBpc1Byb21pc2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU/LnRoZW4gIT0gbnVsbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0FjdHVhbFByb21pc2UodmFsdWUpIHtcbiAgICBjb25zdCBtYXliZVByb21pc2UgPSB2YWx1ZTtcbiAgICByZXR1cm4gbWF5YmVQcm9taXNlICYmIG1heWJlUHJvbWlzZS50aGVuICYmIG1heWJlUHJvbWlzZS5jYXRjaCAmJiBtYXliZVByb21pc2UuZmluYWxseTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVNYXliZVByb21pc2UoaW5wdXRGYWN0b3J5LCBvdXRwdXRTdWNjZXNzRmFjdG9yeSwgb3V0cHV0RXJyb3JGYWN0b3J5LCBmaW5hbGx5RmFjdG9yeSkge1xuICAgIGxldCByZXN1bHQkID0gZmFrZVByb21pc2UoKS50aGVuKGlucHV0RmFjdG9yeSkudGhlbihvdXRwdXRTdWNjZXNzRmFjdG9yeSwgb3V0cHV0RXJyb3JGYWN0b3J5KTtcbiAgICBpZiAoZmluYWxseUZhY3RvcnkpIHtcbiAgICAgICAgcmVzdWx0JCA9IHJlc3VsdCQuZmluYWxseShmaW5hbGx5RmFjdG9yeSk7XG4gICAgfVxuICAgIHJldHVybiB1bmZha2VQcm9taXNlKHJlc3VsdCQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZha2VQcm9taXNlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICYmIGlzQWN0dWFsUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAoaXNQcm9taXNlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGhlbjogKHJlc29sdmUsIHJlamVjdCkgPT4gZmFrZVByb21pc2UodmFsdWUudGhlbihyZXNvbHZlLCByZWplY3QpKSxcbiAgICAgICAgICAgIGNhdGNoOiByZWplY3QgPT4gZmFrZVByb21pc2UodmFsdWUudGhlbihyZXMgPT4gcmVzLCByZWplY3QpKSxcbiAgICAgICAgICAgIGZpbmFsbHk6IGNiID0+IGZha2VQcm9taXNlKGNiID8gcHJvbWlzZUxpa2VGaW5hbGx5KHZhbHVlLCBjYikgOiB2YWx1ZSksXG4gICAgICAgICAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ1Byb21pc2UnLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBXcml0ZSBhIGZha2UgcHJvbWlzZSB0byBhdm9pZCB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvclxuICAgIC8vIGJlaW5nIGNhbGxlZCB3aXRoIGBuZXcgUHJvbWlzZWAgaW4gdGhlIGJyb3dzZXIuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGhlbihyZXNvbHZlKSB7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWtlUHJvbWlzZShyZXNvbHZlKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZha2VSZWplY3RQcm9taXNlKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGNhdGNoKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmFsbHkoY2IpIHtcbiAgICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWtlUHJvbWlzZShjYigpKS50aGVuKCgpID0+IHZhbHVlLCAoKSA9PiB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZha2VSZWplY3RQcm9taXNlKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnUHJvbWlzZScsXG4gICAgICAgIF9fZmFrZVByb21pc2VWYWx1ZTogdmFsdWUsXG4gICAgICAgIFtrRmFrZVByb21pc2VdOiAncmVzb2x2ZWQnLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGVmZXJyZWRQcm9taXNlKCkge1xuICAgIGlmIChQcm9taXNlLndpdGhSZXNvbHZlcnMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2Uud2l0aFJlc29sdmVycygpO1xuICAgIH1cbiAgICBsZXQgcmVzb2x2ZUZuO1xuICAgIGxldCByZWplY3RGbjtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gZGVmZXJyZWRQcm9taXNlRXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJlc29sdmVGbiA9IHJlc29sdmU7XG4gICAgICAgIHJlamVjdEZuID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb21pc2UsXG4gICAgICAgIGdldCByZXNvbHZlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVGbjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHJlamVjdCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3RGbjtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IHsgaXRlcmF0ZUFzeW5jIGFzIGl0ZXJhdGVBc3luY1ZvaWQgfTtcbmV4cG9ydCBmdW5jdGlvbiBpdGVyYXRlQXN5bmMoaXRlcmFibGUsIGNhbGxiYWNrLCByZXN1bHRzKSB7XG4gICAgaWYgKGl0ZXJhYmxlPy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZ1bmN0aW9uIGl0ZXJhdGUoKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZTogZW5kT2ZJdGVyYXRvciwgdmFsdWUgfSA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKGVuZE9mSXRlcmF0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZW5kZWRFYXJseSA9IGZhbHNlO1xuICAgICAgICBmdW5jdGlvbiBlbmRFYXJseSgpIHtcbiAgICAgICAgICAgIGVuZGVkRWFybHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVNYXliZVByb21pc2UoZnVuY3Rpb24gaGFuZGxlQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodmFsdWUsIGVuZEVhcmx5LCBpbmRleCsrKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gaGFuZGxlQ2FsbGJhY2tSZXN1bHQocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cz8ucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZGVkRWFybHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZXJhdGUoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmYWtlUmVqZWN0UHJvbWlzZShlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRoZW4oX3Jlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgaWYgKHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWtlUHJvbWlzZShyZWplY3QoZXJyb3IpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFrZVJlamVjdFByb21pc2UoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcbiAgICAgICAgY2F0Y2gocmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAocmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZha2VQcm9taXNlKHJlamVjdChlcnJvcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWtlUmVqZWN0UHJvbWlzZShlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBmaW5hbGx5KGNiKSB7XG4gICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWtlUmVqZWN0UHJvbWlzZShlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgICAgICBfX2Zha2VSZWplY3RFcnJvcjogZXJyb3IsXG4gICAgICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnUHJvbWlzZScsXG4gICAgICAgIFtrRmFrZVByb21pc2VdOiAncmVqZWN0ZWQnLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gbWFwTWF5YmVQcm9taXNlKGlucHV0LCBvblN1Y2Nlc3MsIG9uRXJyb3IpIHtcbiAgICByZXR1cm4gaGFuZGxlTWF5YmVQcm9taXNlKCgpID0+IGlucHV0LCBvblN1Y2Nlc3MsIG9uRXJyb3IpO1xufVxuLyoqXG4gKiBHaXZlbiBhbiBBc3luY0l0ZXJhYmxlIGFuZCBhIGNhbGxiYWNrIGZ1bmN0aW9uLCByZXR1cm4gYW4gQXN5bmNJdGVyYXRvclxuICogd2hpY2ggcHJvZHVjZXMgdmFsdWVzIG1hcHBlZCB2aWEgY2FsbGluZyB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBBc3luY0l0ZXJhdG9yKGl0ZXJhdG9yLCBvbk5leHQsIG9uRXJyb3IsIG9uRW5kKSB7XG4gICAgaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIGl0ZXJhdG9yKSB7XG4gICAgICAgIGl0ZXJhdG9yID0gaXRlcmF0b3JbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIGxldCAkcmV0dXJuO1xuICAgIGxldCBhYnJ1cHRDbG9zZTtcbiAgICBsZXQgb25FbmRXaXRoVmFsdWU7XG4gICAgaWYgKG9uRW5kKSB7XG4gICAgICAgIGxldCBvbkVuZFdpdGhWYWx1ZVJlc3VsdCAvKiogUiBpbiBvbkVuZFdpdGhWYWx1ZSAqLztcbiAgICAgICAgb25FbmRXaXRoVmFsdWUgPSB2YWx1ZSA9PiB7XG4gICAgICAgICAgICBvbkVuZFdpdGhWYWx1ZVJlc3VsdCB8fD0gaGFuZGxlTWF5YmVQcm9taXNlKG9uRW5kLCAoKSA9PiB2YWx1ZSwgKCkgPT4gdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIG9uRW5kV2l0aFZhbHVlUmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yLnJldHVybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAkcmV0dXJuID0gaXRlcmF0b3IucmV0dXJuO1xuICAgICAgICBhYnJ1cHRDbG9zZSA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmV0aHJvdyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gJHJldHVybi5jYWxsKGl0ZXJhdG9yKS50aGVuKHJldGhyb3csIHJldGhyb3cpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYXBSZXN1bHQocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9uRW5kV2l0aFZhbHVlID8gb25FbmRXaXRoVmFsdWUocmVzdWx0KSA6IHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlTWF5YmVQcm9taXNlKCgpID0+IHJlc3VsdC52YWx1ZSwgdmFsdWUgPT4gaGFuZGxlTWF5YmVQcm9taXNlKCgpID0+IG9uTmV4dCh2YWx1ZSksIGl0ZXJhdG9yUmVzdWx0LCBhYnJ1cHRDbG9zZSkpO1xuICAgIH1cbiAgICBsZXQgbWFwUmVqZWN0O1xuICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgIGxldCBvbkVycm9yUmVzdWx0O1xuICAgICAgICAvLyBDYXB0dXJlIHJlamVjdENhbGxiYWNrIHRvIGVuc3VyZSBpdCBjYW5ub3QgYmUgbnVsbC5cbiAgICAgICAgY29uc3QgcmVqZWN0ID0gb25FcnJvcjtcbiAgICAgICAgbWFwUmVqZWN0ID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBvbkVycm9yUmVzdWx0IHx8PSBoYW5kbGVNYXliZVByb21pc2UoKCkgPT4gZXJyb3IsIGVycm9yID0+IGhhbmRsZU1heWJlUHJvbWlzZSgoKSA9PiByZWplY3QoZXJyb3IpLCBpdGVyYXRvclJlc3VsdCwgYWJydXB0Q2xvc2UpKTtcbiAgICAgICAgICAgIHJldHVybiBvbkVycm9yUmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBuZXh0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yLm5leHQoKS50aGVuKG1hcFJlc3VsdCwgbWFwUmVqZWN0KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmV0dXJuKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzJCA9ICRyZXR1cm5cbiAgICAgICAgICAgICAgICA/ICRyZXR1cm4uY2FsbChpdGVyYXRvcikudGhlbihtYXBSZXN1bHQsIG1hcFJlamVjdClcbiAgICAgICAgICAgICAgICA6IGZha2VQcm9taXNlKHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBvbkVuZFdpdGhWYWx1ZSA/IHJlcyQudGhlbihvbkVuZFdpdGhWYWx1ZSkgOiByZXMkO1xuICAgICAgICB9LFxuICAgICAgICB0aHJvdyhlcnJvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvci50aHJvdyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvci50aHJvdyhlcnJvcikudGhlbihtYXBSZXN1bHQsIG1hcFJlamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWJydXB0Q2xvc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWJydXB0Q2xvc2UoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZha2VSZWplY3RQcm9taXNlKGVycm9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBpdGVyYXRvclJlc3VsdCh2YWx1ZSkge1xuICAgIHJldHVybiB7IHZhbHVlLCBkb25lOiBmYWxzZSB9O1xufVxuZnVuY3Rpb24gaXNGYWtlUHJvbWlzZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZT8uW2tGYWtlUHJvbWlzZV0gPT09ICdyZXNvbHZlZCc7XG59XG5mdW5jdGlvbiBpc0Zha2VSZWplY3RQcm9taXNlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlPy5ba0Zha2VQcm9taXNlXSA9PT0gJ3JlamVjdGVkJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBwcm9taXNlTGlrZUZpbmFsbHkodmFsdWUsIG9uRmluYWxseSkge1xuICAgIGlmICgnZmluYWxseScgaW4gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmZpbmFsbHkob25GaW5hbGx5KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnRoZW4ocmVzID0+IHtcbiAgICAgICAgY29uc3QgZmluYWxseVJlcyA9IG9uRmluYWxseSgpO1xuICAgICAgICByZXR1cm4gaXNQcm9taXNlKGZpbmFsbHlSZXMpID8gZmluYWxseVJlcy50aGVuKCgpID0+IHJlcykgOiByZXM7XG4gICAgfSwgZXJyID0+IHtcbiAgICAgICAgY29uc3QgZmluYWxseVJlcyA9IG9uRmluYWxseSgpO1xuICAgICAgICBpZiAoaXNQcm9taXNlKGZpbmFsbHlSZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmluYWxseVJlcy50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVuZmFrZVByb21pc2UocHJvbWlzZSkge1xuICAgIGlmIChpc0Zha2VQcm9taXNlKHByb21pc2UpKSB7XG4gICAgICAgIHJldHVybiBwcm9taXNlLl9fZmFrZVByb21pc2VWYWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzRmFrZVJlamVjdFByb21pc2UocHJvbWlzZSkpIHtcbiAgICAgICAgdGhyb3cgcHJvbWlzZS5fX2Zha2VSZWplY3RFcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@whatwg-node/promise-helpers/esm/index.js\n");

/***/ })

};
;